package dataStructure.message;

import java.util.HashSet;
import java.util.Stack;

import dataStructure.DarkPeer;
import protocol.LinkableProtocol;
import protocol.MessageProtocol;

public class GetMessage extends ForwardMessage {
	
	private final Stack<DarkPeer> routingPath;
	
	public GetMessage(float messageLocationKey, int HTL) {
		super(messageLocationKey, HTL);
		routingPath = new Stack<DarkPeer>();
	}
	
	/**
	 * Constructor used when the {@code GetMessage} generated by a node who didn't create the original get request.
	 * This happens when a node receives a {@code GetNotFoundMessage} and forward a new {@code GetMessage} to one of his
	 * neighbors that has still to visit. 
	 * @param messageLocationKey key of the content that we want to find
	 * @param HTL Hops-To-Live
	 * @param originId the id of the node who created the get message
	 * @param originalMessageId the id of the original message, it is used by {@code alreadySeen} in {@code MessageProtocol}
	 */
	public GetMessage(float messageLocationKey, int HTL, double bestDistance, long originalMessageId, int originalHTL, 
			HashSet<DarkPeer> allPeersVisited, Stack<DarkPeer> routingPath) {
		super(messageLocationKey, HTL, bestDistance, originalMessageId, originalHTL, allPeersVisited);
		this.routingPath = routingPath;
	}
	
	public GetMessage(GetMessage another){
		super(another);
		routingPath = another.routingPath;
	}

	@Override
	public void doMessageAction(DarkPeer sender, MessageProtocol mp) {
		//add this node to the list of visited nodes
		//debugging check: a node can't receive the same get message twice
		if(!allPeersVisited.add(sender))
			throw new RuntimeException("message "+this+" already seen "+sender.getID());
		//if the node has the searched content
		if(sender.containsKey(this.messageLocationKey)){
			MessageProtocol.printPeerAction(sender, this, "FOUND HERE!");
		}
		//if the node doesn't have the searched message...
		else {
			//if this peer is closer than all the previous peer w.r.t. the content key, reset HTL
			this.isBestDistance(sender, sender.getDistanceFromLocationKey(this.messageLocationKey));
			//forward the GetMessage to the closest node w.r.t the content key
			//note that we don't forward the message to nodes that already received this message
			DarkPeer receiver = ((LinkableProtocol) sender.getProtocol(mp.getLpId()))
					.getClosestNeighbor(this.messageLocationKey, this.allPeersVisited);
			//if no receiver is available, it means one of these two cases:
			//1. that we are going to create a cycle (think to a triangle)
			//2. the only neighbor is the one who sent this message
			if(receiver == null || this.getHTL()==0){
				//in any case, create a GetNotFoudnMessage
				if(this.getHTL() == 0)
					MessageProtocol.printPeerAction(sender, this, "DYING!");
				else
					MessageProtocol.printPeerAction(sender, this, "NO NEIGHBORS AVAILABLE!");
				GetNotFoundMessage message = new GetNotFoundMessage(messageLocationKey, allPeersVisited, 
						routingPath, originalMessageId, originalHTL, this.getHTL(), this.getBestDistance());
				mp.sendBackwardMessage(sender, message);
			}
			//forward the message only if HTL > 0 AND there is at least a neighbor available
			else{
				//add the current node to the routing path
				routingPath.add(sender);
				mp.sendForwardMessage(sender, receiver, this);
			}
		}
	}
	
	@Override
	public Object clone() {
		return new GetMessage(this);
	}


}
